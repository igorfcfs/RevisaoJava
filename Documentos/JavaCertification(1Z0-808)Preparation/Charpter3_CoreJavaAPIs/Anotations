Anotations

--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------

String Class

Creating and manipulating Strings

String name = "Fluffy";
String name = new String("Fluffy");

String is a special class that don't need to use new

In this section, we’ll look at concatenation, immutability, the string pool, common methods,
and method chaining.


Concatenation

Rules:
1. If both operands are numeric, + means numeric addition.
2. If either operand is a String, + means concatenation.
3. The expression is evaluated left to right.

System.out.println(1 + 2); // 3
System.out.println("a" + "b"); // ab
System.out.println("a" + "b" + 3); // ab3
System.out.println(1 + 2 + "c"); // 3c


String s = "1"; // s currently holds "1"
s += "2"; // s currently holds "12"
s += 3; // s currently holds "123"
System.out.println(s); // 123

Immutability
immutable objects only has a getter, a setter makes it mutable

String s1 = "1";
String s2 = s1.concat("2"); // concat() is another way to do 'String s2 = s1 + "2";'
s2.concat("3"); // its does nothing because string is immutable
System.out.println(s2); // output: 12


The String Pool

Since strings are everywhere in Java, they use up a lot of memory. In some production appli-
cations, they can use up 25–40 percent of the memory in the entire program. Java realizes
that many strings repeat in the program and solves this issue by reusing common ones. The
string pool, also known as the intern pool, is a location in the Java virtual machine (JVM)
that collects all these strings.

String name1 = "Fluffy"; // string pool, string literals
String name2 = new String("Fluffy"); // non-string pool, less efficient

The former says to use the string pool normally. The second says “No, JVM. I really
don’t want you to use the string pool. Please create a new object for me even though it is
less efficient.” When you write programs, you wouldn’t want to do this. For the exam, you
need to know that it is allowed.

name1 == "Fluffy" -> true
name2 == "Fluffy" -> false


String pool = "pool";
pool = "x";
pool = "pool";

the object that contains the string "x" is eligible for garbage collector

String pool = new String("pool");
pool = "x";
pool = "pool";

the object that contains the string "x" and the first one that contains a string pool as well the last one is eligible for garbage collector


-------------------------------------------------------------------------------------------------


Thirteen Important String Methods

*length is an field of arrays, length() is a string method, size() is a list method, all of them does the same thing
*index begin with 0

1. length() -> returns the number of characters in the String

method signature - int length()

String string = "animals";
System.out.println(string.length()); // 7


2. charAt() -> lets you query the string to fi nd out what character is at a specific index.

method signature - char charAt(int index)

String string = "animals";
System.out.println(string.charAt(0)); // a
System.out.println(string.charAt(6)); // s
System.out.println(string.charAt(7)); // throws exception: java.lang.StringIndexOutOfBoundsException


3. indexOf() -> looks at the characters in the string and fi nds the fi rst index that
matches the desired value. indexOf can work with an individual character or a whole String
as input. It can also start from a requested position.

method signatures:
int indexOf(int ch)
int indexOf(int ch, int fromIndex)
int indexOf(String str)
int indexOf(String str, int fromIndex)


String string = "animals";
System.out.println(string.indexOf('a')); // 0
System.out.println(string.indexOf("al")); // 4
System.out.println(string.indexOf('a', 4)); // 4
System.out.println(string.indexOf("al", 5)); // -1


4. substring() -> looks for characters in a string. It returns parts of the string.

method signatures:
String substring(int beginIndex)
String substring(int beginIndex, int endIndex)
*beginIndex are inclusive, endIndex are exclusive

String string = "animals";
System.out.println(string.substring(3)); // mals
System.out.println(string.substring(string.indexOf('m'))); // mals
System.out.println(string.substring(3, 4)); // m
System.out.println(string.substring(3, 7)); // mals


System.out.println(string.substring(3, 3)); // empty string
System.out.println(string.substring(3, 2)); // throws exception
System.out.println(string.substring(3, 8)); // throws exception


5 & 6. toLowerCase() & toUpperCase()

method signatures:
String toLowerCase()
String toUpperCase()

String string = "animals";
System.out.println(string.toUpperCase()); // ANIMALS
System.out.println("Abc123".toLowerCase()); // abc123


7 & 8. equals() & equalsIgnoreCase()

The equals() method checks whether two String objects contain exactly the same char-
acters in the same order. The equalsIgnoreCase() method checks whether two String
objects contain the same characters with the exception that it will convert the characters’
case if needed.

method signatures:
boolean equals(Object obj)
boolean equalsIgnoreCase(String str)

System.out.println("abc".equals("ABC")); // false
System.out.println("ABC".equals("ABC")); // true
System.out.println("abc".equalsIgnoreCase("ABC")); // true


9 & 10. startsWith() & endsWith()

The startsWith() and endsWith() methods look at whether the provided value matches
part of the String.

method signatures:
boolean startsWith(String prefix)
boolean endsWith(String suffix)

System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false
System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false


11. contains() -> looks for matches in the String. It isn’t as particular as startsWith()
and endsWith()—the match can be anywhere in the String.

method signature -> boolean contains(String str)

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false

case-sensitive search


12. replace() -> does a simple search and replace on the string. There’s a version that takes
char parameters as well as a version that takes CharSequence parameters. A CharSequence is a
general way of representing several classes, including String and StringBuilder.
It’s called an interface.

method signatures:
String replace(char oldChar, char newChar)
String replace(CharSequence oldChar, CharSequence newChar)

System.out.println("abcabc".replace('a', 'A')); // AbcAbc
System.out.println("abcabc".replace("a", "A")); // AbcAbc
The fi rst example uses the fi rst method signature, passing in char parameters. The
second example uses the second method signature, passing in String parameters.


13. trim() -> removes whitespace from the beginning and end of a String. In terms of the exam,
whitespace consists of spaces along with the \t (tab) and \n (newline) characters.
Other characters, such as \r (carriage return), are also included in what gets trimmed.

method signature: public String trim()

System.out.println("abc".trim()); // abc
System.out.println("\t a b c\n".trim()); // a b c

The fi rst example prints the original string because there are no whitespace characters
at the beginning or end. The second example gets rid of the leading tab, subsequent spaces,
and the trailing newline. It leaves the spaces that are in the middle of the string.



Method Chaining -> String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result); -> ao invés de executar cada função linha por linha, faz que nem uma
corrente e executa tudo em uma linha so trazendo mais praticidade ao programa


--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------


Using StringBuilder class

Code with String:

String alpha = "";
for(char current = 'a'; current <= 'z'; current++)
	alpha += current;
System.out.println(alpha);

27 objects are instantiated on this code


Code with StringBuilder
StringBuilder alpha = new StringBuilder();
for(char current = 'a'; current <= 'z'; current++)
	alpha.append(current);
System.out.println(alpha);

Only 1 object are instantiated on this code



Mutability and Chaining

StringBuilder sb = new StringBuilder("start");
sb.append("+middle"); // sb = "start+middle"
StringBuilder same = sb.append("+end"); // "start+middle+end"


StringBuilder a = new StringBuilder("abc");
StringBuilder b = a.append("de");
b = b.append("f").append("g");
System.out.println("a=" + a);
System.out.println("b=" + b);

Creating a StringBuilder

There are three ways to construct a StringBuilder
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);

The first says to create a StringBuilder containing an empty sequence of characters and
assign sb1 to point to it.

The second says to create a StringBuilder containing a specific
value and assign sb2 to point to it.

For the first two, it tells Java to manage the implementa-
tion details.

The final example tells Java that we have some idea of how big the eventual value
will be and would like the StringBuilder to reserve a certain number of slots for characters.


Size vs. Capacity
Size is the number of characters currently in the sequence, and capacity is the number
of characters the sequence can currently hold. Since a String is immutable, the size and
capacity are the same. The number of characters appearing in the String is both the size
and capacity.

For StringBuilder, Java knows the size is likely to change as the object is used. When
StringBuilder is constructed, it may start at the default capacity (which happens to be
16) or one of the programmer’s choosing. In the example, we request a capacity of 5. At
this point, the size is 0 since no characters have been added yet, but we have space for 5.

Next we add four characters. At this point, the size is 4 since four slots are taken. The
capacity is still 5. Then we add three more characters. The size is now 7 since we have
used up seven slots. Because the capacity wasn’t large enough to store seven characters,
Java automatically increased it for us.


StringBuilder sb = new StringBuilder(5);

0 1 2 3 4


sb.append("anim");

a n i m
0 1 2 3 4

sb.append("als");

a n i m a l s
0 1 2 3 4 5 6 …7


Important StringBuilder Methods

charAt(), indexOf(), length(), and substring()
These four methods work exactly the same as in the String class. Be sure you can identify
the output of this example:

StringBuilder sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);

The correct answer is anim 7 s.


The indexOf() method calls return 0 and 4, respectively.

substring() returns the String starting with index 0 and ending right before index 4.

length() returns 7 because it is the number of characters in the StringBuilder rather
than an index. 

charAt() returns the character at index 6. Here we do start with 0 because we are referring
to indexes.

Notice that substring() returns a String rather than a StringBuilder. That is why sb
is not changed. substring() is really just a method that inquires about where the substring
happens to be.



1. append() -> adds the parameter to the StringBuilder and returns a reference to the current
StringBuilder.

method signature: StringBuilder append(String str)

StringBuilder sb = new StringBuilder().append(1).append('c');
sb.append("-").append(true);
System.out.println(sb); // 1c-true


2. insert() -> adds characters to the StringBuilder at the requested index and returns a
reference to the current StringBuilder.

method signature: StringBuilder insert(int offset, String str)

StringBuilder sb = new StringBuilder("animals");
sb.insert(7, "-"); // sb = animals-
sb.insert(0, "-"); // sb = -animals-
sb.insert(4, "-"); // sb = -ani-mals-
System.out.println(sb);


3 & 4. delete & deleteCharAt() -> The delete() method is the opposite of the insert() method.
It removes characters from the sequence and returns a reference to the current StringBuilder.
The deleteCharAt() method is convenient when you want to delete only one character.

method signatures:
StringBuilder delete(int start, int end)
StringBuilder deleteCharAt(int index)

StringBuilder sb = new StringBuilder("abcdef");
sb.delete(1, 3); // sb = adef
sb.deleteCharAt(5); // throws an exception


5. reverse() -> reverses the characters in the sequences and returns a reference to the current
StringBuilder.

method signature: StringBuilder reverse()

StringBuilder sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb); // CBA


6. toString() -> converts a StringBuilder into a String.

method signature: String toString()

String s = sb.toString();

Often StringBuilder is used internally for performance purposes but the end result
needs to be a String. For example, maybe it needs to be passed to another method that is
expecting a String.

StringBuffer X StringBuilder
StringBuffer is old() and slowly because its thread safe
StringBuilder is more recent(Java 5) and faster


Understanding Equality

StringBuilder one = new StringBuilder();
StringBuilder two = new StringBuilder();
StringBuilder three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true


String x = "Hello World";
String y = "Hello World";
System.out.println(x == y); // true

String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x == z); // false

String x = new String("Hello World");
String y = "Hello World";
System.out.println(x == y); // false

String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x.equals(z)); // true


public class Tiger {
	String name;
	public static void main(String[] args) {
     	Tiger t1 = new Tiger();
     	Tiger t2 = new Tiger();
     	Tiger t3 = t1;
     	System.out.println(t1 == t3); // true
     	System.out.println(t1 == t2); // false, 
		System.out.println(t1.equals(t2)); // false, Tiger does not implements equals
	}
}

String and StringBuilder are a sequence of characters




-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------





Understanding Java Arrays
an array is an ordered list. It can contain duplicates.

char[] letters; // sequence of characters, we could use this statement instead String or StringBuilder,
but its not good, because we would lost all the benefits of a String.

Creating an array of primitive types
int[] x = new int[2];
int [] x = new int[] {1, 2, 3};
int x[] = {1, 23, 4};

-------------------------------------------------------------------------------------------------

Multiple arrays is declaration

int[] x, y; != int x[], y; => No primeiro os dois sao arrais de int, no segundo, somente o x e um array de int,
o y e uma variavel do tipo int normal.

-------------------------------------------------------------------------------------------------

Creating and array with Reference Variables
public class ArrayType {
    public static void main(String args[]) {
        String [] bugs = { "cricket", "beetle", "ladybug" };
        String [] alias = bugs;
        System.out.println(bugs.equals(alias)); // true
        System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
        System.out.println(bugs == alias); // true
        System.out.println(bugs); // [Ljava.lang.String;@160bc7c0
    }
}


String[] strings = { "stringValue" };
Object[] objects = strings;
String[] againStrings = (String[]) objects;
againStrings[0] = new StringBuilder(); // DOES NOT COMPILE
objects[0] = new StringBuilder(); // careful! Throws an ArrayStoreException

Line 3 creates an array of type String. Line 4 doesn’t require a cast because Object is
a broader type than String. On line 5, a cast is needed because we are moving to a more
specific type. Line 6 doesn’t compile because a String[] only allows String objects and
StringBuilder is not a String.

Line 7 is where this gets interesting. From the point of view of the compiler, this is just
fine. A StringBuilder object can clearly go in an Object[]. The problem is that we don’t
actually have an Object[]. We have a String[] referred to from an Object[] variable. At
runtime, the code throws an ArrayStoreException. You don’t need to memorize the name
of this exception, but you do need to know that the code will throw an exception.

-------------------------------------------------------------------------------------------------

Using and Array

String[] mammals = {"monkey", "chimp", "donkey"};
System.out.println(mammals.length); // 3
System.out.println(mammals[0]); // monkey
System.out.println(mammals[1]); // chimp
System.out.println(mammals[2]); // donkey

String[] birds = new String[6];
System.out.println(birds.length); //if birds was null, it would output the stack trace of NullPointerException

The answer is 6. Even though all 6 elements of the array are null, there are still 6 of
them. length does not consider what is in the array; it only considers how many slots have
been allocated.


int[] numbers = new int[10];
for (int i = 0; i < numbers.length; i++)
   numbers[i] = i + 5;

Numbers is an array of size 10:
numbers[10] = 3;
numbers[numbers.length] = 5;
for (int i = 0; i <= numbers.length; i++) numbers[i] = i + 5;

The first one is trying to see if you know that indexes start with 0. Since we have 10
elements in our array, this means only numbers[0] through numbers[9] are valid. The second
example assumes you are clever enough to know 10 is invalid and disguises it by using
the length field. However, the length is always one more than the maximum valid index.
Finally, the for loop incorrectly uses <= instead of <, which is also a way of referring to that
10th element.

-------------------------------------------------------------------------------------------------

Sorting
import java.util.*; // import whole package including Arrays
import java.util.Arrays; // import just Arrays

There is one exception, although it doesn’t come up often on the exam. You can write
java.util.Arrays every time it is used in the class instead of specifying it as an import.
Remember that if you are shown a code snippet with a line number that doesn’t begin
with 1, you can assume the necessary imports are there. Similarly, you can assume the
imports are present if you are shown a snippet of a method.

This simple example sorts three numbers:

int[] numbers = { 6, 9, 1 };
Arrays.sort(numbers);
for (int i = 0; i < numbers.length; i++)
	System.out.print (numbers[i] + " "); // 1 6 9

The result is 1 6 9, as you should expect it to be. Notice that we had to loop through
the output to print the values in the array. Just printing the array variable directly would
give the annoying hash of [I@2bd9c3e7.

Try this again with String types:

String[] strings = { "10", "9", "100" };
Arrays.sort(strings);
for (String string : strings)
	System.out.print(string + " "); // 10 100 9

This time the result might not be what you expect. This code outputs 10 100 9. The
problem is that String sorts in alphabetic order, and 1 sorts before 9. (Numbers sort before
letters and uppercase sorts before lowercase, in case you were wondering.).


-------------------------------------------------------------------------------------------------


Searching

Java also provides a convenient way to search (binary search) — but only if the array is already sorted.

Binary search rules
Scenario Result
Target element found in sorted array     |    Index of match

Target element not found in sorted array |    Negative value showing one smaller than the
										 |    negative of index, where a match needs to be
										 |    inserted to preserve sorted order
										 
Unsorted array 							 |    A surprise—this result isn’t predictable


int[] numbers = {2,4,6,8};
System.out.println(Arrays.binarySearch(numbers, 2)); // 0 -> esse e o index do elemento 2
System.out.println(Arrays.binarySearch(numbers, 4)); // 1 -> esse e o index do elemento 4
System.out.println(Arrays.binarySearch(numbers, 1)); // -1 -> deveria ser o elemento na posicao 0 segundo a ordem,entao 0 -1 = -1
System.out.println(Arrays.binarySearch(numbers, 3)); // -2 -> deveria ser o elemento na posicao 1 segundo a ordem, entao -1 -1 = -2
System.out.println(Arrays.binarySearch(numbers, 9)); // -5 -> deveria ser o elemento na posicao 4 segundo a ordem, entao -4 -1 = -5

Take note of the fact that line 3 is a sorted array. If it weren’t, we couldn’t apply either
of the other rules. Line 4 searches for the index of 2. The answer is index 0. Line 5 searches
for the index of 4, which is 1.

Line 6 searches for the index of 1. Although 1 isn’t in the list, the search can determine
that it should be inserted at element 0 to preserve the sorted order. Since 0 already means
something for array indexes, Java needs to subtract 1 to give us the answer of –1. Line 7
is similar. Although 3 isn’t in the list, it would need to be inserted at element 1 to preserve
the sorted order. We negate and subtract 1 for consistency, getting –1 –1, also known as
–2. Finally, line 8 wants to tell us that 9 should be inserted at index 4. We again negate and
subtract 1, getting –4 –1, also known as –5.



int[] numbers = new int[] {3,2,1};
System.out.println(Arrays.binarySearch(numbers, 2));
System.out.println(Arrays.binarySearch(numbers, 3));

unpredictable output


-------------------------------------------------------------------------------------------------


Varargs

When creating an array yourself, it looks like what we’ve seen thus far. When one is passed
to your method, there is another way it can look. Here are three examples with a main()
method:
public static void main(String[] args)
public static void main(String args[])
public static void main(String... args) // varargs


The third example uses a syntax called varargs (variable arguments), which you saw in
Chapter 1. You’ll learn how to call a method using varargs in Chapter 4, “Methods and
Encapsulation.” For now, all you need to know is that you can use a variable defi ned using
varargs as if it were a normal array. For example args.length and args[0] are legal.


-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------


Multidimensional Array

Arrays are objects, and of course array components can be objects. It doesn’t take much
time, rubbing those two facts together, to wonder if arrays can hold other arrays, and of
course they can.

Creating a Multidimensional Array
String [][] rectangle = new String[3][2];
rectangle[0][1] = "set";


int[][] differentSize = {{1, 4}, {3}, {9,8,7}};

Another way to create an asymmetric array is to initialize just an array’s fi rst dimension,
and defi ne the size of each array component in a separate statement:
int [][] args = new int[4][];
args[0] = new int[5];
args[1] = new int[3];

-------------------------------------------------------------------------------------------------

Using a Multidimensional Array

int[][] twoD = new int[3][2];
for (int i = 0; i < twoD.length; i++) {
for (int j = 0; j < twoD[i].length; j++)
System.out.print(twoD[i][j] + " "); // print element
System.out.println(); // time for a new row
}

for (int[] inner : twoD) {
	for (int num : inner)
		System.out.print(num + " ");
	System.out.println();
}




-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------



Understanding an Array List

An array has one glaring shortcoming: you have to know how many elements will be in the
array when you create it and then you are stuck with that choice. Just like a StringBuilder,
ArrayList can change size at runtime as needed. Like an array, an ArrayList is an ordered
sequence that allows duplicates.

As when we used Arrays.sort, ArrayList requires an import. To use it, you must have
either of the following two statements in your class:
import java.util.*; // import whole package including ArrayList
import java.util.ArrayList; // import just ArrayList


Creating an Array List

As with StringBuilder, there are three ways to create an ArrayList:



ArrayList list1 = new ArrayList();
ArrayList list2 = new ArrayList(10);
ArrayList list3 = new ArrayList(list2);



The first says to create an ArrayList containing space for the default number of
elements but not to fill any slots yet. The second says to create an ArrayList containing a
specific number of slots, but again not to assign any. The final example tells Java that we
want to make a copy of another ArrayList. We copy both the size and contents of that
ArrayList. Granted, list2 is empty in this example so it isn’t particularly interesting.
Although these are the only three constructors you need to know, you do need to learn
some variants of it.

The previous examples were the old pre–Java 5 way of creating an
ArrayList. They still work and you still need to know they work.


You also need to know the new and improved way. Java 5 introduced generics,
which allow you to specify the type of class that the ArrayList will contain.



ArrayList<String> list4 = new ArrayList<String>();
ArrayList<String> list5 = new ArrayList<>(); // Java 7
ArrayList<> list6 = new ArrayList<>(); // does not compile



Java 5 allows you to tell the compiler what the type would be by specifying it between <
and >. Starting in Java 7, you can even omit that type from the right side. The < and > are
still required, though. This is called the diamond operator because <> looks like a diamond.
Just when you thought you knew everything about creating an ArrayList, there is one
more thing you need to know. ArrayList implements an interface called List.

In other words, an ArrayList is a List.In the meantime, just know that you can
store an ArrayList in a List reference variable but not vice versa.

The reason is that List is an interface and interfaces can’t be instantiated.



List<String> list6 = new ArrayList<>();
ArrayList<String> list7 = new List<>(); // DOES NOT COMPILE




Using an ArrayList
ArrayList has many methods, but you only need to know a handful of them—even fewer
than you did for String and StringBuilder.

Before reading any further, you are going to see something new in the method signatures:
a “class” named E. Don’t worry — it isn’t really a class. E is used by convention in generics
to mean “any class that this array can hold.” If you didn’t specify a type when creating the
ArrayList, E means Object. Otherwise, it means the class you put between < and >.

You should also know that ArrayList implements toString() so you can easily see the
contents just by printing it. Arrays do not do produce such pretty output.





1. add() -> insert a new value in the ArrayList.

method signature:
boolean add(E element)
void add(int index, E element)

Don’t worry about the boolean return value. It always returns true. It is there because
other classes in the collections family need a return value in the signature when adding an
element.



ArrayList list = new ArrayList();
list.add("hawk"); // [hawk]
list.add(Boolean.TRUE); // [hawk, true]
System.out.println(list); // [hawk, true]



add() does exactly what we expect: it stores the String in the no longer empty
ArrayList. It then does the same thing for the boolean. This is okay because we didn’t
specify a type for ArrayList; therefore, the type is Object, which includes everything
except primitives. It may not have been what we intended, but the compiler doesn’t know
that. Now, let’s use generics to tell the compiler we only want to allow String objects in
our ArrayList:



ArrayList<String> safer = new ArrayList<>();
safer.add("sparrow");
safer.add(Boolean.TRUE); // DOES NOT COMPILE





This time the compiler knows that only String objects are allowed in and prevents the
attempt to add a boolean. Now let’s try adding multiple values to different positions.



List<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
birds.add(1, "robin"); // [hawk, robin]
birds.add(0, "blue jay"); // [blue jay, hawk, robin]
birds.add(1, "cardinal"); // [blue jay, cardinal, hawk, robin]
System.out.println(birds); // [blue jay, cardinal, hawk, robin]



2. remove() -> remove the fi rst matching value in the ArrayList or remove the
element at a specified index.

method signatures:
boolean remove(Object object)
E remove(int index)

This time the boolean return value tells us whether a match was removed. The E return
type is the element that actually got removed. The following shows how to use these
methods:

List<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
birds.add("hawk"); // [hawk, hawk]
System.out.println(birds.remove("cardinal")); // prints false
System.out.println(birds.remove("hawk")); // prints true
System.out.println(birds.remove(0)); // prints hawk
System.out.println(birds); // []

Line 6 tries to remove an element that is not in birds. It returns false because no such
element is found. Line 7 tries to remove an element that is in birds and so returns true.
Notice that it removes only one match. Line 8 removes the element at index 0, which is the
last remaining element in the ArrayList.

Since calling remove() with an int uses the index, an index that doesn’t exist will throw
an exception. For example, birds.remove(100) throws an IndexOutOfBoundsException.
There is also a removeIf() method. We’ll cover it in the next chapter because it uses
lambda expressions (a topic in that chapter).



3. set() -> changes one of the elements of the ArrayList without changing the size.

method signature: E set(int index, E newElement)

List<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
System.out.println(birds.size()); // 1
birds.set(0, "robin"); // [robin]
System.out.println(birds.size()); // 1
birds.set(1, "robin"); // IndexOutOfBoundsException

Line 16 adds one element to the array, making the size 1. Line 18 replaces that one element
and the size stays at 1. Line 20 tries to replace an element that isn’t in the ArrayList.
Since the size is 1, the only valid index is 0. Java throws an exception because this isn’t
allowed.


4 & 5. isEmpty() & size() -> look at how many of the slots are in use.

method signatures:
boolean isEmpty()
int size()

List<String> birds = new ArrayList<>();
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size()); // 0
birds.add("hawk"); // [hawk]
birds.add("hawk"); // [hawk, hawk]
System.out.println(birds.isEmpty()); // false
System.out.println(birds.size()); // 2

At the beginning, birds has a size of 0 and is empty. It has a capacity that is greater
than 0. However, as with StringBuilder, we don’t use the capacity in determining size or
length. After adding elements, the size becomes positive and it is no longer empty.


6. clear() -> provides an easy way to discard all elements of the ArrayList.

method signature: void clear()

List<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
birds.add("hawk"); // [hawk, hawk]

System.out.println(birds.isEmpty()); // false

System.out.println(birds.size()); // 2
birds.clear(); // []

System.out.println(birds.isEmpty()); // true
System.out.println(birds.size()); // 0
After we call clear(), birds is back to being an empty ArrayList of size 0.


7. contains() -> checks whether a certain value is in the ArrayList.

method signature: boolean contains(Object object)

List<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
System.out.println(birds.contains("hawk")); // true
System.out.println(birds.contains("robin")); // false

This method calls equals() on each element of the ArrayList to see whether there are
any matches. Since String implements equals(), this works out well.


8. equals() -> ArrayList has a custom implementation of equals() so you can compare two lists
to see if they contain the same elements in the same order.

method signature:
boolean equals(Object object)

List<String> one = new ArrayList<>();
List<String> two = new ArrayList<>();

System.out.println(one.equals(two)); // true
one.add("a"); // [a]

System.out.println(one.equals(two)); // false
two.add("a"); // [a]

System.out.println(one.equals(two)); // true
one.add("b"); // [a,b]
two.add(0, "b"); // [b,a]

System.out.println(one.equals(two)); // false



Wrapper Classes

Primitive type 		Wrapper class 		Example of constructing
boolean 			Boolean 			new Boolean(true)
byte 				Byte 				new Byte((byte) 1)
short 				Short 				new Short((short) 1)
int 				Integer 			new Integer(1)
long 				Long 				new Long(1)
float 				Float 				new Float(1.0)
double 				Double 				new Double(1.0)
char 				Character 			new Character('c')


int primitive = Integer.parseInt("123"); // converts the string into a primitive int
Integer wrapper = Integer.valueOf("123"); // converts the string into a wrapper class Integer

Converting from a String
Wrapper class 			Converting String to primitive		Converting String to wrapper class
Boolean 				Boolean.parseBoolean("true"); 		Boolean.valueOf("TRUE");
Byte 					Byte.parseByte("1"); 				Byte.valueOf("2");
Short 					Short.parseShort("1"); 				Short.valueOf("2");
Integer 				Integer.parseInt("1"); 				Integer.valueOf("2");
Long 					Long.parseLong("1"); 				Long.valueOf("2");
Float 					Float.parseFloat("1"); 				Float.valueOf("2.2");
Double 					Double.parseDouble("1"); 			Double.valueOf("2.2");
Character 				None 								None




Autoboxing

List<Double> weights = new ArrayList<>();
5: weights.add(50.5); // [50.5]
6: weights.add(new Double(60)); // [50.5, 60.0]
7: weights.remove(50.5); // [60.0]
8: double first = weights.get(0); // 60.0

List<Integer> heights = new ArrayList<>();
4: heights.add(null);
5: int h = heights.get(0); // NullPointerException

List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.remove(1); // 1 is the index, so it will remove the element 2, If you want to remove the 2, you can write numbers.remove(new Integer(2)) to force wrapper class use.
System.out.println(numbers);




Converting Between array and List


Converting an ArrayList to an array

List<String> list = new ArrayList<>();
list.add("hawk");
list.add("robin");
Object[] objectArray = list.toArray();
System.out.println(objectArray.length); // 2
String[] stringArray = list.toArray(new String[0]);
System.out.println(stringArray.length); // 2



Converting an array to ArrayList

String[] array = { "hawk", "robin" }; // [hawk, robin]
List<String> list = Arrays.asList(array); // returns fixed size list
System.out.println(list.size()); // 2
list.set(1, "test"); // [hawk, test]
array[0] = "new"; // [new, test]
for (String b : array) System.out.print(b + " "); // new test
list.remove(1); // throws UnsupportedOperationException


List<String> list = Arrays.asList("one", "two"); // a immutable list in one line, with varargs

Sorting
List<Integer> numbers = new ArrayList<>();
numbers.add(99);
numbers.add(5);
numbers.add(81);
Collections.sort(numbers);
System.out.println(numbers); // [5, 81, 99]



-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------



Working with Dates and Times

import java.time.*; // import time classes

LocalDate -> Contains just a date—no time and no time zone. Birthday
LocalTime -> Contains just a time—no date and no time zone. Midnight
LocalDateTime -> Contains both a date and time but no time zone. The strokes of Midnight New Year

System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());

output:
2015-01-20
12:45:18.401
2015-01-20T12:45:18.401

the month comes before the date in united states, and they use a 12-hour clock with a.m. and p.m.


LocalDate
LocalDate date1 = LocalDate.of(2015, Month.JANUARY, 20);
LocalDate date2 = LocalDate.of(2015, 1, 20);

method signatures of of() of LocalDate:
public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)



LocalTime
LocalTime time1 = LocalTime.of(6, 15); // hour and minute
LocalTime time2 = LocalTime.of(6, 15, 30); // + seconds
LocalTime time3 = LocalTime.of(6, 15, 30, 200); // + nanoseconds

method signatures of of() of LocalTime:
public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)



LocalDateTime
LocalDateTime dateTime1 = LocalDateTime.of(2015, Month.JANUARY, 20, 6, 15, 30);
LocalDateTime dateTime2 = LocalDateTime.of(date1, time1);

method signatures of of() of LocalDateTime:
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(LocalDate date, LocalTime time)

Possible Trick Questions with Dates:
LocalDate d = new LocalDate(); // DOES NOT COMPILE
LocalDate.of(2015, Month.JANUARY, 32); // throws DateTimeException, 32 is a invalid day of month
    
    Janeiro – 31 dias
    Fevereiro – 28 dias normais ou 29 nos anos bissextos (qualquer ano divisível por 4)
    Março – 31 dias
    Abril – 30 dias
    Maio – 31 dias
    Junho – 30 dias
    Julho – 31 dias
    Agosto – 31 dias
    Setembro – 30 dias
    Outubro – 31 dias
    Novembro – 30 dias
    Dezembro – 31 dias



Manipulating Dates and Times

Adding to a date is easy. The date and time classes are immutable, just like String was.
This means that we need to remember to assign the results of these methods to a reference
variable so they are not lost.

Go forward in time
LocalDate date = LocalDate.of(2014, Month.JANUARY, 20);
System.out.println(date); // 2014-01-20
date = date.plusDays(2);
System.out.println(date); // 2014-01-22
date = date.plusWeeks(1);
System.out.println(date); // 2014-01-29
date = date.plusMonths(1);
System.out.println(date); // 2014-02-28
date = date.plusYears(5);
System.out.println(date); // 2019-02-28

Go backward in time
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(5, 15);
LocalDateTime dateTime = LocalDateTime.of(date, time);
System.out.println(dateTime); // 2020-01-20T05:15
dateTime = dateTime.minusDays(1);
System.out.println(dateTime); // 2020-01-19T05:15
dateTime = dateTime.minusHours(10);
System.out.println(dateTime); // 2020-01-18T19:15
dateTime = dateTime.minusSeconds(30);
System.out.println(dateTime); // 2020-01-18T19:14:30


Chaining methods
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(5, 15);
LocalDateTime dateTime = LocalDateTime.of(date, time)
.minusDays(1).minusHours(10).minusSeconds(30);



LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
date.plusDays(10); // useless, LocalDate is immutable
System.out.println(date); // January, 20, 2020

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
date = date.plusMinutes(1); // DOES NOT COMPILE, LocalDate does not contain time


Methods in LocalDate, LocalTime e LocalDateTime
							Can call on LocalDate?		Can call on LocalTime?		Can call on LocalDateTime?
plusYears/minusYears 		Yes 						No 							Yes
plusMonths/minusMonths 		Yes 						No 							Yes
plusWeeks/minusWeeks 		Yes 						No 							Yes
plusDays/minusDays 			Yes 						No 							Yes
plusHours/minusHours 		No 							Yes 						Yes
plusMinutes/minusMinutes 	No 							Yes 						Yes
plusSeconds/minusSeconds 	No 							Yes 						Yes
plusNanos/minusNanos 		No 							Yes 						Yes



Working with Periods

Code without Period
public static void main(String[] args) {
	LocalDate start = LocalDate.of(2015, Month.JANUARY, 1);
	LocalDate end = LocalDate.of(2015, Month.MARCH, 30);
	performAnimalEnrichment(start, end);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end) {
	LocalDate upTo = start;
	while (upTo.isBefore(end)) { // check if still before end
	System.out.println("give new toy: " + upTo);
	upTo = upTo.plusMonths(1); // add a month, problem: this method can't be reused, because it just add a month
}}

Code with Period
public static void main(String[] args) {
	LocalDate start = LocalDate.of(2015, Month.JANUARY, 1);
	LocalDate end = LocalDate.of(2015, Month.MARCH, 30);
	Period period = Period.ofMonths(1); // create a period
	performAnimalEnrichment(start, end, period);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end,
	Period period) { // uses the generic period
	LocalDate upTo = start;
	while (upTo.isBefore(end)) {
	System.out.println("give new toy: " + upTo);
	upTo = upTo.plus(period); // adds the period, solution: now I can reuse this method, is just change the period
}}


There are five ways to create a Period class:
Period annually = Period.ofYears(1); // every 1 year
Period quarterly = Period.ofMonths(3); // every 3 months
Period everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
Period everyOtherDay = Period.ofDays(2); // every 2 days
Period everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days

There’s one catch. You cannot chain methods when creating a Period. The following
code looks like it is equivalent to the everyYearAndAWeek example, but it’s not. Only the
last method is used because the Period.ofXXX methods are static methods.
Period wrong = Period.ofYears(1).ofWeeks(1); // every week

Period wrong = Period.ofYears(1);
wrong = Period.ofWeeks(1);

This is clearly not what you intended! That’s why the of() method allows us to pass in
the number of years, months, and days. They are all included in the same period. You will
get a compiler warning about this. Compiler warnings tell you something is wrong or suspi-
cious without failing compilation.


LocalDate date = LocalDate.of(2015, 1, 20);
LocalTime time = LocalTime.of(6, 15);
LocalDateTime dateTime = LocalDateTime.of(date, time);
Period period = Period.ofMonths(1);
System.out.println(date.plus(period)); // 2015-02-20
System.out.println(dateTime.plus(period)); // 2015-02-20T06:15
System.out.println(time.plus(period)); // UnsupportedTemporalTypeException




Formatting Dates and Times

The date and time classes support many methods to get data out of them:
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
System.out.println(date.getDayOfWeek()); // MONDAY
System.out.println(date.getMonth()); // JANUARY
System.out.println(date.getYear()); // 2020
System.out.println(date.getDayOfYear()); // 20

We could use this information to display information about the date. However, it would
be more work than necessary. Java provides a class called DateTimeFormatter to help us
out. Unlike the LocalDateTime class, DateTimeFormatter can be used to format any type of
date and/or time object. What changes is the format. DateTimeFormatter is in the package
java.time.format.

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
System.out.println(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

ISO is a standard for dates. The output of the previous code looks like this:
2020-01-20
11:12:34
2020-01-20T11:12:34



DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(shortDateTime.format(dateTime)); // 1/20/20
System.out.println(shortDateTime.format(date)); // 1/20/20
System.out.println(shortDateTime.format(time)); // UnsupportedTemporalTypeException

Here we say we want a localized formatter in the predefined short format. The last line
throws an exception because a time cannot be formatted as a date. The format() method is
declared on both the formatter objects and the date/time objects, allowing you to reference
the objects in either order. The following statements print exactly the same thing as the
previous code:

DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(dateTime.format(shortDateTime));
System.out.println(date.format(shortDateTime));
System.out.println(time.format(shortDateTime));


ofLocalized methods:

DateTimeFormatter f = DateTime Formatter._____(FormatStyle.SHORT);

								Calling f.format(localDate)		Calling f.format(localDateTime)		Calling f.format(localTime)
ofLocalizedDate 				Legal – shows whole object		Legal – shows just date part		Throws runtime exception

ofLocalizedDateTime 			Throws runtime exception		Legal – shows whole object			Throws runtime exception									

ofLocalizedTime 				Throws runtime exception		Legal – shows just time part		Legal – shows whole object


There are two predefined formats that can show up on the exam: SHORT and MEDIUM. The
other predefined formats involve time zones, which are not on the exam.

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);

DateTimeFormatter shortF = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
DateTimeFormatter mediumF = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);

System.out.println(shortF.format(dateTime)); // 1/20/20 11:12 AM
System.out.println(mediumF.format(dateTime)); // Jan 20, 2020 11:12:34 AM



If you don’t want to use one of the predefined formats, you can create your own. For
example, this code spells out the month:


DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
System.out.println(dateTime.format(f)); // January 20, 2020, 11:12


Before we look at the syntax, know you are not expected to memorize what different
numbers of each symbol mean. The most you will need to do is recognize the date and time
pieces.

MMMM -> M represents the month. The more Ms you have, the more verbose the Java output. For example, M outputs 1, MM outputs 01, MMM outputs Jan, and MMMM outputs January.

dd -> d represents the date in the month. As with month, the more ds you have, the more
verbose the Java output. dd means to include the leading zero for a single-digit day.

, -> Use , if you want to output a comma (this also appears after the year).

yyyy: y represents the year. yy outputs a two-digit year and yyyy outputs a four-digit year.

hh -> h represents the hour. Use hh to include the leading zero if you’re outputting a single-
digit hour.

: ->  Use : if you want to output a colon.

mm -> m represents the minute.

DateTimeFormatter f = DateTimeFormatter.ofPattern("hh:mm");
f.format(dateTime);
f.format(date); // throws an UnsupportedTemporalTypeException
f.format(time);



Parsing Dates and Times
Now that you know how to convert a date or time to a formatted String, you’ll find it easy
to convert a String to a date or time. Just like the format() method, the parse() method
takes a formatter as well. If you don’t specify one, it uses the default for that type.

DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", f);
LocalTime time = LocalTime.parse("11:22");
System.out.println(date); // 2015-01-02
System.out.println(time); // 11:22

Here we show using both a custom formatter and a default value. This isn’t common,
but you might have to read code that looks like this on the exam. Parsing is consistent in
that if anything goes wrong, Java throws a runtime exception. That could be a format that
doesn’t match the String to be parsed or an invalid date.



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------


Summary
In this chapter, you learned that Strings are immutable sequences of characters. The new
operator is optional. The concatenation operator (+) creates a new String with the con-
tent of the first String followed by the content of the second String. If either operand
involved in the + expression is a String, concatenation is used; otherwise, addition is used.
String literals are stored in the string pool. The String class has many methods. You need
to know charAt(), concat(), endsWith(), equals(), equalsIgnoreCase(), indexOf(),
length(), replace(), startsWith(), substring(), toLowerCase(), toUpperCase(), and
trim().

StringBuilders are mutable sequences of characters. Most of the methods return a
reference to the current object to allow method chaining. The StringBuilder class has
many methods. You need to know append(), charAt(), delete(), deleteCharAt(),
indexOf(), insert(), length(), reverse(), substring(), and toString(). StringBuffer
is the same as StringBuilder except that it is thread safe.

Calling == on String objects will check whether they point to the same object in the
pool. Calling == on StringBuilder references will check whether they are pointing to the
same StringBuilder object. Calling equals() on String objects will check whether the
sequence of characters is the same. Calling equals() on StringBuilder objects will check
whether they are pointing to the same object rather than looking at the values inside.
An array is a fi xed-size area of memory on the heap that has space for primitives or
pointers to objects. You specify the size when creating it—for example, int[] a = new
int[6];. Indexes begin with 0 and elements are referred to using a[0]. The Arrays.sort()
method sorts an array. Arrays.binarySearch() searches a sorted array and returns the
index of a match. If no match is found, it negates the position where the element would
need to be inserted and subtracts 1. Methods that are passed varargs (…) can be used as
if a normal array was passed in. In a multidimensional array, the second-level arrays and
beyond can be different sizes.

An ArrayList can change size over its life. It can be stored in an ArrayList or List
reference. Generics can specify the type that goes in the ArrayList. You need to know the
methods add(), clear(), contains(), equals(), isEmpty(), remove(), set(), and size().
Although an ArrayList is not allowed to contain primitives, Java will autobox parameters
passed in to the proper wrapper type. Collections.sort() sorts an ArrayList.

A LocalDate contains just a date, a LocalTime contains just a time, and a LocalDateTime
contains both a date and time. All three have private constructors and are created using
LocalDate.now() or LocalDate.of() (or the equivalents for that class). Dates and times
can be manipulated using plus XXX or minus XXX methods. The Period class represents a
number of days, months, or years to add or subtract from a LocalDate or LocalDateTime.
DateTimeFormatter is used to output dates and times in the desired format. The date and
time classes are all immutable, which means the return value must be used.



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Exam Essentials
Be able to determine the output of code using String. Know the rules for concatenat-
ing Strings and how to use common String methods. Know that Strings are immutable.
Pay special attention to the fact that indexes are zero based and that substring() gets the
string up until right before the index of the second parameter.

Be able to determine the output of code using StringBuilder. Know that
StringBuilder is mutable and how to use common StringBuilder methods. Know that
substring() does not change the value of a StringBuilder whereas append(), delete(),
and insert() do change it. Also note that most StringBuilder methods return a reference
to the current instance of StringBuilder.

Understand the difference between == and equals. == checks object equality. equals()
depends on the implementation of the object it is being called on. For Strings, equals()
checks the characters inside of it.

Be able to determine the output of code using arrays. Know how to declare and instanti-
ate one-dimensional and multidimensional arrays. Be able to access each element and know
when an index is out of bounds. Recognize correct and incorrect output when searching
and sorting.

Be able to determine the output of code using ArrayList. Know that ArrayList can
increase in size. Be able to identify the different ways of declaring and instantiating an
ArrayList. Identify correct output from ArrayList methods, including the impact of
autoboxing.

Recognize invalid uses of dates and times. LocalDate does not contain time fields and
LocalTime does not contain date fields. Watch for operations being performed on the
wrong time. Also watch for adding or subtracting time and ignoring the result.
